// server.js - Servidor Backend Unificado para Ferremax con PayPal y Admin CRUD

// --- DEPENDENCIAS ---
const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
const bcrypt = require('bcrypt');
const paypal = require('@paypal/checkout-server-sdk');
require('dotenv').config();

// --- CONFIGURACIÓN ---
const app = express();
const PORT = process.env.PORT || 4000;
const saltRounds = 10;

// --- CONFIGURACIÓN PAYPAL ---
const PAYPAL_CLIENT_ID = process.env.PAYPAL_CLIENT_ID;
const PAYPAL_CLIENT_SECRET = process.env.PAYPAL_CLIENT_SECRET;
if (!PAYPAL_CLIENT_ID || !PAYPAL_CLIENT_SECRET) { console.error("\n!!! ERROR FATAL: Credenciales PayPal no definidas en .env\n"); process.exit(1); }
let environment; const isProduction = process.env.NODE_ENV === 'production';
if (isProduction) { console.log("--> Configurando PayPal en modo: Live"); environment = new paypal.core.LiveEnvironment(PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET); }
else { console.log("--> Configurando PayPal en modo: Sandbox"); environment = new paypal.core.SandboxEnvironment(PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET); }
let client = new paypal.core.PayPalHttpClient(environment);
console.log(`--> PayPal Client ID (Backend): ...${PAYPAL_CLIENT_ID.slice(-6)}`);

// --- MIDDLEWARE ---
app.use(cors()); app.use(express.json()); app.use(express.urlencoded({ extended: true }));

// --- CONEXIÓN BASE DE DATOS ---
let dbPool;
try {
     dbPool = mysql.createPool({ host: process.env.DB_HOST || 'localhost', user: process.env.DB_USER || 'root', password: process.env.DB_PASSWORD || '', database: process.env.DB_NAME || 'ferremax_db', waitForConnections: true, connectionLimit: 10, queueLimit: 0 });
     dbPool.getConnection().then(c => { console.log(`--> Conexión DB OK ('${c.config.database}')`); c.release(); }).catch(err => { console.error(`!!! Error conexión DB (${err.code || 'N/A'}): ${err.message}`); });
} catch (error) { console.error("!!! Error CRÍTICO creando pool DB:", error); process.exit(1); }

// --- MIDDLEWARE DE AUTENTICACIÓN ADMIN (Placeholder) ---
const checkAdmin = (req, res, next) => {
    // !! Placeholder - Reemplazar con lógica real de sesión/token JWT !!
    const isAdminSimulated = req.headers['x-admin-simulated'] === 'true';
    if (isAdminSimulated) { next(); }
    else { res.status(403).json({ success: false, message: 'Acceso denegado (Admin requerido).' }); }
};

// --- RUTAS DE AUTENTICACIÓN ---
app.post('/register', async (req, res) => { try { const { username, email, password } = req.body; if (!username || !email || !password || password.length < 6) { return res.status(400).json({ success: false, message: 'Datos inválidos.' }); } const [existingUser] = await dbPool.query('SELECT id FROM usuarios WHERE email = ? LIMIT 1', [email]); if (existingUser.length > 0) { return res.status(409).json({ success: false, message: 'Correo ya registrado.' }); } const hashedPassword = await bcrypt.hash(password, saltRounds); const [result] = await dbPool.query('INSERT INTO usuarios (username, email, password) VALUES (?, ?, ?)', [username, email, hashedPassword]); console.log(`--> Usuario registrado: ${username} (ID: ${result.insertId})`); res.status(201).json({ success: true, message: 'Usuario registrado.' }); } catch (error) { console.error('!!! Error en /register:', error); res.status(500).json({ success: false, message: 'Error interno.' }); } });
app.post('/login', async (req, res) => { try { const { email, password } = req.body; if (!email || !password) { return res.status(400).json({ success: false, message: 'Correo/Pass requeridos.' }); } const [users] = await dbPool.query('SELECT id, username, email, password, role FROM usuarios WHERE email = ? LIMIT 1', [email]); if (users.length === 0) { return res.status(401).json({ success: false, message: 'Credenciales incorrectas.' }); } const user = users[0]; const match = await bcrypt.compare(password, user.password); if (match) { console.log(`--> Login OK: ${user.username} (Rol: ${user.role})`); res.status(200).json({ success: true, message: 'Login OK.', user: { id: user.id, username: user.username, email: user.email, role: user.role } }); } else { res.status(401).json({ success: false, message: 'Credenciales incorrectas.' }); } } catch (error) { console.error('!!! Error en /login:', error); res.status(500).json({ success: false, message: 'Error interno.' }); } });

// --- RUTAS PÚBLICAS (PRODUCTOS, CONTACTO SIMULADO, PAYPAL) ---
app.get('/api/productos', async (req, res) => { try { const [results] = await dbPool.query('SELECT ID_Producto, Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url FROM producto'); res.status(200).json(results); } catch (error) { console.error('!!! Error GET /api/productos:', error); res.status(500).json({ success: false, message: 'Error obtener productos.' }); } });
app.get('/api/productos/:id', async (req, res) => { try { const { id } = req.params; if (isNaN(id)) { return res.status(400).json({ success: false, message: 'ID inválido.' }); } const [results] = await dbPool.query('SELECT ID_Producto, Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url FROM producto WHERE ID_Producto = ?', [id]); if (results.length === 0) { return res.status(404).json({ success: false, message: 'Producto no encontrado.' }); } res.status(200).json(results[0]); } catch (error) { console.error(`!!! Error GET /api/productos/${id}:`, error); res.status(500).json({ success: false, message: 'Error obtener producto.' }); } });
app.post('/api/contact', async (req, res) => { try { const { name, email } = req.body; console.log(`--> Mensaje contacto RECIBIDO (Sim): De ${name} <${email}>`); res.status(200).json({ success: true, message: 'Mensaje recibido.' }); } catch (error) { console.error("Error simulando contacto:", error); res.status(500).json({ success: false, message: "Error interno." }); } });
app.post('/api/orders', async (req, res) => { try { const { productId } = req.body; if (!productId || isNaN(productId)) { return res.status(400).json({ success: false, message: "ID inválido." }); } let product; try { const [results] = await dbPool.query('SELECT ID_Producto, Nombre, precio_unitario FROM producto WHERE ID_Producto = ? LIMIT 1', [productId]); if (results.length === 0) { return res.status(404).json({ success: false, message: "P. no encontrado." }); } product = { id: results[0].ID_Producto, name: results[0].Nombre, price: parseFloat(results[0].precio_unitario) }; if (isNaN(product.price) || product.price <= 0) { return res.status(400).json({ success: false, message: "Precio inválido." }); } } catch (dbError) { console.error(`!!! Error DB P${productId}:`, dbError); return res.status(500).json({ success: false, message: "Error consultando P." }); } const request = new paypal.orders.OrdersCreateRequest(); request.prefer("return=representation"); request.requestBody({ intent: 'CAPTURE', purchase_units: [{ amount: { currency_code: 'USD', value: product.price.toFixed(2) }, description: `Compra ${product.name}` }] }); console.log(`--> Creando orden P${productId}, $${product.price.toFixed(2)}`); const order = await client.execute(request); console.log(`--> Orden CREADA: ${order.result.id}`); res.status(201).json({ id: order.result.id }); } catch (err) { console.error("!!! Error CREAR orden:", err.message || err); if (err.statusCode) { const d=err.result?JSON.stringify(err.result):err.message; console.error(`PayPal Error ${err.statusCode}: ${d}`); return res.status(err.statusCode).json({ success: false, message: err.result?.message || "Error PayPal." }); } res.status(500).json({ success: false, message: "Error interno." }); } });
app.post('/api/orders/:orderID/capture', async (req, res) => { try { const { orderID } = req.params; console.log(`--> Capturando: ${orderID}`); const request = new paypal.orders.OrdersCaptureRequest(orderID); request.requestBody({}); const capture = await client.execute(request); const d = capture.result; console.log(`--> CAPTURA: ${orderID}, Estado: ${d.status}`); if (d.status !== 'COMPLETED') { console.warn(`--> Captura NO COMPLETADA: ${d.status}`); return res.status(400).json({ success: false, message: `Estado: '${d.status}'.` }); } console.log(`--> Pago COMPLETADO: ${orderID}.`); const p = d.purchase_units?.[0]?.payments?.captures?.[0]; if (p) { console.log(`--> Capture ID: ${p.id}, Monto: ${p.amount?.value} ${p.amount?.currency_code}`); } console.log(`--> TODO: Lógica post-pago ${orderID}`); res.status(200).json({ success: true, capture: d }); } catch (err) { console.error(`!!! Error CAPTURAR ${req.params.orderID}:`, err.message || err); if (err.statusCode) { const d=err.result?JSON.stringify(err.result):err.message; console.error(`PayPal Error ${err.statusCode}: ${d}`); const i = err.result?.details?.[0]?.issue; let m = err.result?.message || "Error PayPal."; let pe = i || 'UNKNOWN'; if (i==='INSTRUMENT_DECLINED'){m="Pago declinado.";pe='INSTRUMENT_DECLINED';} else if (i==='ORDER_ALREADY_CAPTURED'){m="Ya procesada.";pe='ORDER_ALREADY_CAPTURED';} else if (i==='ORDER_NOT_APPROVED'){m="No aprobada.";pe='ORDER_NOT_APPROVED';} return res.status(err.statusCode).json({ success: false, message: m, paypal_error: pe }); } res.status(500).json({ success: false, message: "Error interno." }); } });

// --- RUTAS DE ADMINISTRACIÓN ---

// GET Categorías
app.get('/api/categories', async (req, res) => { try { console.log("--> GET /api/categories"); const [results] = await dbPool.query('SELECT ID_Categoria, Nombre FROM categoria ORDER BY Nombre ASC'); res.status(200).json(results); } catch (error) { console.error('!!! Error GET /api/categories:', error.message); console.error('!!! Código DB:', error.code); res.status(500).json({ success: false, message: 'Error obtener categorías.' }); } });

// GET Productos Admin
app.get('/api/admin/products', checkAdmin, async (req, res) => { try { console.log("--> GET /api/admin/products"); const [results] = await dbPool.query('SELECT ID_Producto, Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url FROM producto ORDER BY ID_Producto ASC'); res.status(200).json(results); } catch (error) { console.error('!!! Error GET /api/admin/products:', error); res.status(500).json({ success: false, message: 'Error obtener productos admin.' }); } });

// GET Producto Individual Admin (para editar)
app.get('/api/admin/products/:id', checkAdmin, async (req, res) => { const { id } = req.params; console.log(`--> GET /api/admin/products/${id}`); if (isNaN(id)) { return res.status(400).json({ success: false, message: 'ID inválido.' }); } try { const [results] = await dbPool.query('SELECT * FROM producto WHERE ID_Producto = ?', [id]); if (results.length === 0) { return res.status(404).json({ success: false, message: 'P. no encontrado.' }); } res.status(200).json(results[0]); } catch (error) { console.error(`!!! Error GET /api/admin/products/${id}:`, error); res.status(500).json({ success: false, message: 'Error obtener P. para editar.' }); } });

// POST Añadir Producto
app.post('/api/admin/products', checkAdmin, async (req, res) => { try { console.log("--> POST /api/admin/products"); const { Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url } = req.body; if (!Nombre || precio_unitario === undefined || cantidad === undefined || !Marca) { return res.status(400).json({ success: false, message: 'Faltan datos (*).' }); } const precioNum = parseFloat(precio_unitario); const cantidadNum = parseInt(cantidad, 10); const categoriaId = ID_Categoria ? parseInt(ID_Categoria, 10) : null; if (isNaN(precioNum) || precioNum < 0) { return res.status(400).json({ success: false, message: 'Precio inválido.' }); } if (isNaN(cantidadNum) || cantidadNum < 0) { return res.status(400).json({ success: false, message: 'Cantidad inválida.' }); } if (ID_Categoria && isNaN(categoriaId)) { return res.status(400).json({ success: false, message: 'ID Categoría inválido.' }); } const sql = `INSERT INTO producto (Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`; const values = [ Nombre, Descripcion || null, precioNum, Marca, Codigo_Barras || null, categoriaId, cantidadNum, imagen_url || null ]; const [result] = await dbPool.query(sql, values); console.log(`--> Producto añadido ID: ${result.insertId}`); res.status(201).json({ success: true, message: 'Producto añadido.', productId: result.insertId }); } catch (error) { console.error('!!! Error POST /api/admin/products:', error); if (error.code === 'ER_DUP_ENTRY') { return res.status(409).json({ success: false, message: 'Error: Código barras duplicado.' }); } res.status(500).json({ success: false, message: 'Error interno al añadir.' }); } });

// PUT para ACTUALIZAR un producto (protegido)
app.put('/api/admin/products/:id', checkAdmin, async (req, res) => { const { id } = req.params; console.log(`--> PUT /api/admin/products/${id}`); if (isNaN(id)) { return res.status(400).json({ success: false, message: 'ID inválido.' }); } const { Nombre, Descripcion, precio_unitario, Marca, Codigo_Barras, ID_Categoria, cantidad, imagen_url } = req.body; if (!Nombre || precio_unitario === undefined || cantidad === undefined || !Marca) { return res.status(400).json({ success: false, message: 'Faltan datos (*).' }); } const precioNum = parseFloat(precio_unitario); const cantidadNum = parseInt(cantidad, 10); const categoriaId = ID_Categoria ? parseInt(ID_Categoria, 10) : null; if (isNaN(precioNum) || precioNum < 0) { return res.status(400).json({ success: false, message: 'Precio inválido.' }); } if (isNaN(cantidadNum) || cantidadNum < 0) { return res.status(400).json({ success: false, message: 'Cantidad inválida.' }); } if (ID_Categoria && isNaN(categoriaId)) { return res.status(400).json({ success: false, message: 'ID Categoría inválido.' }); } try { const sql = `UPDATE producto SET Nombre = ?, Descripcion = ?, precio_unitario = ?, Marca = ?, Codigo_Barras = ?, ID_Categoria = ?, cantidad = ?, imagen_url = ? WHERE ID_Producto = ?`; const values = [ Nombre, Descripcion || null, precioNum, Marca, Codigo_Barras || null, categoriaId, cantidadNum, imagen_url || null, id ]; const [result] = await dbPool.query(sql, values); if (result.affectedRows === 0) { return res.status(404).json({ success: false, message: 'P. no encontrado para actualizar.' }); } console.log(`--> Producto actualizado ID: ${id}`); res.status(200).json({ success: true, message: 'Producto actualizado.' }); } catch (error) { console.error(`!!! Error PUT /api/admin/products/${id}:`, error); if (error.code === 'ER_DUP_ENTRY') { return res.status(409).json({ success: false, message: 'Error: Cód. barras duplicado.' }); } res.status(500).json({ success: false, message: 'Error interno al actualizar.' }); } });

// DELETE para ELIMINAR un producto (protegido)
app.delete('/api/admin/products/:id', checkAdmin, async (req, res) => { const { id } = req.params; console.log(`--> DELETE /api/admin/products/${id}`); if (isNaN(id)) { return res.status(400).json({ success: false, message: 'ID inválido.' }); } try { const sql = 'DELETE FROM producto WHERE ID_Producto = ?'; const [result] = await dbPool.query(sql, [id]); if (result.affectedRows === 0) { return res.status(404).json({ success: false, message: 'P. no encontrado para eliminar.' }); } console.log(`--> Producto eliminado ID: ${id}`); res.status(200).json({ success: true, message: 'Producto eliminado.' }); } catch (error) { console.error(`!!! Error DELETE /api/admin/products/${id}:`, error); if (error.code === 'ER_ROW_IS_REFERENCED_2') { return res.status(409).json({ success: false, message: 'Error: Producto referenciado (ej. ventas).' }); } res.status(500).json({ success: false, message: 'Error interno al eliminar.' }); } });

// --- INICIAR SERVIDOR ---
app.listen(PORT, () => { console.log(`\n==> Servidor Ferremax en http://localhost:${PORT} [${isProduction ? 'PROD' : 'SANDBOX'}]`); });
// --- MANEJO DE CIERRE GRACEFUL ---
const gracefulShutdown = async (signal) => { console.log(`\n==> ${signal}. Cerrando...`); try { if (dbPool) { await dbPool.end(); console.log('--> Pool DB cerrado.'); } } catch (err) { console.error('!!! Error cerrando pool DB:', err); } finally { console.log("==> Servidor cerrado."); process.exit(0); } };
process.on('SIGINT', gracefulShutdown); process.on('SIGTERM', gracefulShutdown);
